# Freenode programming channel FAQ

This page is intended to be global for the whole [##programming](irc://irc.freenode.net/##programming) channel. So feel free to clone and reuse.

## The Questions

###   How do I talk on the channel?

In order to talk on ##programming, connect your IRC client to the irc.freenode.net server, type /join ##programming and press enter. It is a good idea to register your nickname with the Freenode network (see /msg NickServ HELP). This URL may work for you: <a href="irc://irc.freenode.net/##programming">irc://irc.freenode.net/##programming</a> .

Freenode also provides a web interface here: <a href="http://webchat.freenode.net/">http://webchat.freenode.net/</a> . For more information about viable IRC clients see:

* <a href="http://perl-begin.org/irc/">http://perl-begin.org/irc/</a>
* [http://en.wikipedia.org/wiki/List\_of\_IRC\_clients](http://en.wikipedia.org/wiki/List_of_IRC_clients)

###   What is considered on-topic on ##programming? What is considered off-topic?

Well, we try to concentrate on programming and related Computer Science-related discussions, but sometimes discussions diverge into something different and we're OK with it. Some things that are on-topic:

1. Getting help with specific programming languages technologies, including those that have dedicated channels on Freenode and/or elsewhere, including but not limited to Java, C#/.NET, PHP, Visual Basic (Classic, .NET, Visual Basic for Applications, or whatever), C++, C, Python, Perl, Ruby, JavaScript or whatever. We do not intend to imply we endorse using any of these technologies (and different members of the channels may have different opinions of them) but we still support them.
2. Help with someone's programming or CS homework is also on-topic on ##programming . It is considered unethical to write your homework for you, but you can get different kinds of help.

The reason we agree to discuss such things as discussing such things help the channel grow, make the content of the channel more lively and interesting, and because the traffic generated by them is still not overwhelming enough for us to consider a different policy. (Also see [what “Joel on Software” said about Internet forums becoming too fragmented](http://www.joelonsoftware.com/items/2004/09/03.html).).

Some discussions that are explicitly off-topic:

1. Discussions about global/national politics — these tend to deteriorate very quickly, and many people find them annoying. If you still wish to discuss them, head over to [\#politics](irc://irc.freenode.net/#politics).
2. Personal insults, [Ad hominem](http://en.wikipedia.org/wiki/Ad_hominem) attacks, sexual/racial/political harassment, etc.
3. Illegal activity (as forbidden by Freenode policy).

None of these things will get you banned immediately, but you will be warned and told to stop, and devoiced only if you persist.

###   I tried joining a different channel for help, but I could not - why?

Some channels people try to join to seek help with their technology (notably ##java) require registration at the Freenode services. See [the Freenode FAQ](http://freenode.net/faq.shtml) for more information about user/nickname registration.

Note that you are still welcome to ask questions related to specific technologies on ##programming, but otherwise you'll probably get more help on the topic-specific channels. 

###   Which Integrated Development Environment (IDE) or Text Editor Would You Recommend?

We get asked this question a lot. The answer is a bit long. First of all, it is likely that following editing mechanisms will not be adequate for editing code:

* Rich-text editors including, but not limited to, Microsoft Windows WordPad (formerly known as Windows Write, we were informed that it has a text editing mode, but see below), word processors such as Microsoft Word, OpenOffice.org/LibreOffice Writer, WordPerfect, AbiWord, etc. and WYSIWYG (= "What you see is what you get") HTML editors. These are not suitable for editing code.
* Limited text editors such as Microsoft Windows Notepad (see <http://www.notepad.org/> for a very fun link about it ), or [Pico](https://en.wikipedia.org/wiki/Pico_%28text_editor%29) which are aimed for casual editing of text documents. More capable text editors such as [Notepad++](http://notepad-plus-plus.org/), [Notepad2](http://www.flos-freeware.ch/notepad2.html) and [GNU Nano](http://www.nano-editor.org/), should be OK.

These editors may still be useful if that's all you can use, but if you can afford to install and/or use a more capable text editor, it is by all means a good idea.

Otherwise, asking the channel about the most recommend text editor will end up in people giving you their own preferences (which may have involved many years of trying different solutions, and some time of studying their existing preference and getting accustomed to it). Some links to get you started:

* [The “List of Text Editors and IDEs”](http://www.shlomifish.org/open-source/resources/editors-and-IDEs/) on Shlomi Fish’s homepage. (Not complete, but covers the most prominent solutions).
* [The Text Editors Wiki](http://texteditors.org/)

Note that many decent text editors and IDEs are open-source, free-of-charge, and cross-platform (Windows, Mac OS X and Linux/UNIX). As a result, there is no good excuse not to download one, install it, and use it.

###   I want to learn programming? Which language should I start with?

Different people will give different answers when asked that. Most people on ##programming believe that something like [the Python programming language](https://en.wikipedia.org/wiki/Python_%28programming_language%29) would be a good start. Python is a popular, useful, open source, and cross-platform (runs fine on Windows, Linux and Mac OS X and on many other less common platforms), that is not too hard to learn and get your feet wet with. Some resources to learn Python are:

* [_Learn Python the Hard Way_](http://learnpythonthehardway.org/) - while it has an intimidating title, this book aims to teach beginning programmers proper programming using Python using formal methods.
* [_How to think like a computer scientist - Learning in Python_](http://openbookproject.net/thinkcs/python/english2e/) - a similar book.
* [The Default Python Tutorial](http://docs.python.org/tutorial/) - may not be too useful for people with no programming experience.

Here are some resources for learning other programming languages, whether as a first language or after knowing some other languages:

* [The C/C++ Beginners' Wiki](http://c-begin.wikia.com/wiki/C_and_C%2B%2B_Beginners_Wiki) and the more mature (but with a non-clear licence) [Freenode ##C Wiki](http://www.iso-9899.info/).
* [The Perl Beginners Site](http://perl-begin.org/) for Perl beginners.

###   How should I do binary Input/Output properly?

Some people would naïvely assume that writing a C struct directly to a file would be a good solution for outputting it to disk. That is far from the case, however. The representation of a struct in memory is subject to many system-dependent factors, such as:

* [Endianness](http://en.wikipedia.org/wiki/Endianness) - also referred to as byte sex, this determines whether bytes are stored in memory with the lowest byte first, or the highest one.
* Padding - for efficiency reasons, compilers tend to place empty spaces between the fields of structs. The amount of such space is not standardised, and varies between systems, compilers (and even compilation options can affect it).
* Integral data types and pointers can vary in their nominal size. I.e: an "int" can be 16-bit, 32-bit, or 64-bit, a long can be 32-bit or 64-bit, etc., which is system-dependent.

The O’Reilly book [Porting UNIX Software](http://www.lemis.com/grog/Documentation/PUS/) (available for purchase or download under a Creative Commons licence on the link), goes to further depth about these and many other UNIX portability issues.

In any case, the best way to mitigate this problem portably and safely, is to write (and later read) every field (and sometimes every byte within) to the disk or network. You should be able to find some mechanisms inside [portable libraries](http://www.shlomifish.org/open-source/portability-libs/) to do that.

###   What are some best practices in programming that I should adopt?

First of all, we should note that many best practices may still be controversial to a small or large extent, despite being very common in the industry. We also don't expect a beginning programmer who writes some sample programs to immediately employ all the best practices that go into developing mission-critical software on which lives are dependent.

But here goes with a grain of salt:

1. Use a good [version control system](http://en.wikipedia.org/wiki/Revision_control). For more about version control systems and the motivation behind them see [the “Better SCM” Site](http://better-scm.berlios.de/) and [a related section from “Perl for Perl Newbies”](http://www.shlomifish.org/lecture/Perl/Newbies/lecture5/version-control/) (which is not exclusively limited to Perl) and [Sawyer X’s talk about source code management systems](http://www.slideshare.net/xSawyer/source-code-management-systems).
  * Please don't give the usual cliches that you don't need a version control system if you’re only one person or that the project is not large enough to warrant it. You probably do.
2. Write Automated Tests. See [Test-driven development](http://en.wikipedia.org/wiki/Test-driven_development) and other resources.
3. Use a standard build/configuration system for the language you use. Simple [makefiles](http://en.wikipedia.org/wiki/Makefile) may be adequate for small projects, especially those written in C or C++. If you need to handle dependencies, build-time configuration variables and other complications, you should look at [alternatives for C](http://www.shlomifish.org/open-source/resources/software-tools/) or the community-based alternatives for your programming language of choice (e.g: [setputools](http://en.wikipedia.org/wiki/Setuptools) for Python; [Dist::Zilla](http://dzil.org/) for Perl; [RubyGems](http://en.wikipedia.org/wiki/RubyGems) for Ruby).

For more information consult the essay [“What Makes Software High Quality?”](http://www.shlomifish.org/philosophy/computers/high-quality-software/rev2/) and [the Perl Beginners’s Site “Perl Elements to avoid”](http://perl-begin.org/tutorials/bad-elements/) (which, while focusing on Perl, has a lot of good advice related to other programming languages).

###   What is the best programming language?

We sometimes get asked this question, and the answer is simple: there is none. Different languages have different strengths, weaknesses and often trade offs. You may wish to read the blog post [“(Why) Your Programming Language Must Suck”](http://shlomif-tech.livejournal.com/57811.html) for a short coverage of some of the important trade-offs a language design will have, and why no one will be happy with it all the time.

Even if we settle on a certain amount of preferences, then you may run into other factors that influence which language you may prefer:

1. Should the program run as quickly as possible? Or do you want to optimise for the developers’ time?
2. Is low memory consumption critical?
3. Should the language be portable to various operating systems and/or CPUs? Or is it OK if it only runs somewhere specific?
4. Should the language have an open-source implementation?
5. Should the language have a large user base, and provide quick and useful support?
6. Should bugs be addressed and fixed quickly in the implementations?
7. Should the language have any particular built-in features that you desire?
8. Should the language have an extensive library of extensions and APIs that can be reused?

Etc. If you tell us what your needs are, we can help you with a recommendation.

Note that some of the channel members happen to like a certain programming language in particular and tend to constantly recommend it to other people. Furthermore, you may run into language wars where one or more languages are bashed as awful languages by participants in the channel. That does not mean these languages are necessarily good or bad or suitable for what you wish to do.

###   What are good resources (including books) to learn about algorithms?

Here are some resources for learning about algorithms:

* [The Algorithm Design Manual](http://www.algorist.com/) by Steven Skiena. A good book and not a very technical one that provides a good introduction and reference for algorithms.
* [Wikipedia's list of data structures](http://en.wikipedia.org/wiki/List_of_data_structures) and [Wikipedia's list of algorithms](http://en.wikipedia.org/wiki/List_of_algorithms).
* [The Data Structures Wikibook](http://en.wikibooks.org/wiki/Data_Structures)
* The CC-by book [Open Data Structures](http://opendatastructures.org/).
* [The Book _Introduction to Algorithms_](http://en.wikipedia.org/wiki/Introduction_to_Algorithms) - by Cormen et. all (a.k.a “CLR” or “CLRS”) - a comprehensive reference on algorithms and data structures, but a technical and dry one.

There's also a [channel called "#algorithms" on Freenode](irc://irc.freenode.net/#algorithms) and, naturally, you can discuss algorithms on ##programming, as long as you perform due diligence.

### I have an awesome idea for a great project (probably a game) and I want people to help me…

First of all, we appreciate your enthusiasm, but you should realise that most of us have better things to do than help you (even if they are unemployed), and so you should offer money (and we don't mean a share of the profits.). If not, you are quite unlikely to recruit anyone.

If you cannot offer money, please consider learning the necessary skills yourself (see the above questions) and starting work on your own. If you make your project open-source, and publicise it, then other people may eventually join you, and help you if they find it interesting.

###   What is the difference between “scripting” languages such as Perl, PHP, Python or Ruby and “Industrial-strength” Languages such as C, C++, Java and C#?

Many people have issues with calling dynamic languages, with dynamic typing and those that are of somewhat more open-source nature such as Perl, PHP, Python and Ruby as “scripting” languages. See:

* [Andy Lester's Stop saying “script”](http://xoa.petdance.com/Stop_saying_%22script%22)
* [Larry Wall’s “Programming’s Hard - Let’s Go Scripting”](http://www.perl.com/pub/2007/12/06/soto-11.html)
* [chromatic - “Program vs. Script”](http://use.perl.org/use.perl.org/_chromatic/journal/35804.html)

The problem with calling them that is that it is that while they allow for getting small and simple things done quickly and easily, large scale projects (100,000s to millions lines of code) have been written in them and are still maintained without any show-stopping difficulties. That is not to say that these languages do not have their downsides, but they still do not preclude **general-purpose**, and/or **large-scale** programming.

Furthermore, if we consider Perl/PHP/Python/Ruby/Tcl/Lua/etc. as “scripting languages” and C, C++, Java and C# as “industrial strength” where does Common Lisp fit in? Where does Scheme? Where do Haskell and OCaml? What about the various dialects of Basic? Fortran? COBOL? It seems that the classification of languages as “scripting” vs “industrial strength” is more of that of public perception and marketing as opposed to their actual qualities.

On the other hand, we do not wish to claim here that C, C++, Java and/or C# are necessarily bad languages, or that you should not study them or refuse job offers that involve writing code using them.

###   I need to learn about various base systems, like hexadecimal (base-16), binary (base-2). Where can I find information about them?

See:

* [The English Wikipedia’s Binary Numeral System](https://en.wikipedia.org/wiki/Binary_numeral_system) - and the side bar next to it.
* [wikiHow’s How to Understand Hexadecimal](http://www.wikihow.com/Understand-Hexadecimal)

###   I want to buy some interesting books to read. Can you recommend me some?

Here are some lists of recommended books by some of our regulars:

* [Shlomi Fish’s Book Reviews](http://www.shlomifish.org/philosophy/books-recommends/)
* [vendu’s list of books](https://github.com/vendu/OS-Zero/blob/master/notes/booklist.txt)

In addition, here are some recommended lists of books by some notable software engineers and writers:

* [Joel on Software’s “Book Reviews”](http://www.joelonsoftware.com/navlinks/fog0000000262.html)

###   How do I learn how to use GDB (= the GNU debugger)?

We are often approached by people who tell us their C or C++ (or whatever) program crashes or otherwise misbehaves and then ask us why. If that's the case for you, you should realise that you should learn how to use an interactive debugger in order to debug your program, and you should learn how to do so as soon as possible.

One such debugger is the open source command-line debugger, "gdb", which can be used to debug programs in C, C++ and some other languages. Here is some information on learning to use it:

* [“Software Development on Linux” slides](http://www.shlomifish.org/lecture/W2L/Development/slides/) - a basic introduction to gdb.
* [“Advanced Debugging with gdb”](http://www.shlomifish.org/tel.foss.org.il-temp/lecture-notes/GDB_Linux_telux.pdf) - by David Khosid.
* [“gdb - customize it the way you want”](http://www.haifux.org/lectures/210/) - by guy keren.
